key++: normalize id and lc()

allow signing using an alternate secret key, like in pcpdecrypt()

malloc() new pointers in functions only if not NULL, e.g. pcp_gennonce()

check pub key count in pcp.c before calling verify signature, croak if count==0

Update pod key format spec.

vault checksum: add keysigs as well

enable formats for secret key exports as well

Add newlines to headers in define.h, so strlen() later catches the whole length.

Check is_utf8 license.
  also found in https://gd.meizo.com/_files/lpc/ext/utf8.c

Symmetric decrypt mode tries to open vault

pcp_find_primary_secret() makes a copy ???

c++ destructor double free mess

cpptest 0 uses same Context for encryptor and decryptor,
must be another one for the latter!

after new z85 padding scheme: write z85 blocksize to output
as well? if a reader doesn't know the blocksize it won't be
able to decode it properly. Or no issue? Not sure yet...


(gdb) set args  -V v1 -p -x xxx -z -i 0x8671F4264E20F179
(gdb) r
Starting program: /usr/home/sciplocal/D/github/pcp/src/pcp1 -V v1 -p -x xxx -z -i 0x8671F4264E20F179
failed to decrypt the secret key (got -1, expected 32)!
Error: Operation not permitted

Program received signal SIGSEGV, Segmentation fault.
0x000000000040f8e8 in pcphash_del (ptx=0x801017040, key=0x80107b100, type=Variable "type" is not available.
) at keyhash.c:28
28          HASH_DEL(ptx->pcpkey_hash, (pcp_key_t *)key);
(gdb) bt
#0  0x000000000040f8e8 in pcphash_del (ptx=0x801017040, key=0x80107b100, type=Variable "type" is not available.
) at keyhash.c:28
#1  0x000000000040fba7 in pcphash_clean (ptx=0x801017040) at keyhash.c:50
#2  0x00000000004084ff in ptx_clean (ptx=0x801017040) at context.c:52
#3  0x0000000000402557 in main (argc=Variable "argc" is not available.
) at pcp.c:593




_havenacl sometimes "no", even if old version is installed, followed by:

mem.c:51: warning: implicit declaration of function 'sodium_malloc'
mem.c:51: warning: initialization makes pointer from integer without a cast
