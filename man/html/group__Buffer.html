<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libpcp: BUFFER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpcp
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BUFFER</div>  </div>
</div><!--header-->
<div class="contents">

<p>Flexible buffer management, idea from openssh/buffer.c.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__pcp__buffer.html">_pcp_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flexible buffer object wich automatically resizes, if neccessary.  <a href="struct__pcp__buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2460ea15a51a37433b5f2e1503667e8f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__pcp__buffer.html">_pcp_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a></td></tr>
<tr class="memdesc:ga2460ea15a51a37433b5f2e1503667e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name used everywhere.  <a href="#ga2460ea15a51a37433b5f2e1503667e8f"></a><br/></td></tr>
<tr class="separator:ga2460ea15a51a37433b5f2e1503667e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55e468b36750f28308b7fa5dfea5b564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga55e468b36750f28308b7fa5dfea5b564">buffer_new</a> (size_t blocksize, char *name)</td></tr>
<tr class="memdesc:ga55e468b36750f28308b7fa5dfea5b564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer.  <a href="#ga55e468b36750f28308b7fa5dfea5b564"></a><br/></td></tr>
<tr class="separator:ga55e468b36750f28308b7fa5dfea5b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770f9c4e3caf1bcf315666a56312246f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga770f9c4e3caf1bcf315666a56312246f">buffer_new_str</a> (char *name)</td></tr>
<tr class="memdesc:ga770f9c4e3caf1bcf315666a56312246f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string buffer.  <a href="#ga770f9c4e3caf1bcf315666a56312246f"></a><br/></td></tr>
<tr class="separator:ga770f9c4e3caf1bcf315666a56312246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924b013cdf1e6f7b38ba9d10b3b7112e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga924b013cdf1e6f7b38ba9d10b3b7112e">buffer_new_buf</a> (char *name, void *data, size_t datasize)</td></tr>
<tr class="memdesc:ga924b013cdf1e6f7b38ba9d10b3b7112e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer from existing data.  <a href="#ga924b013cdf1e6f7b38ba9d10b3b7112e"></a><br/></td></tr>
<tr class="separator:ga924b013cdf1e6f7b38ba9d10b3b7112e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c00049898e0ea7d6570748bf9a0e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e">buffer_free</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gaa1c00049898e0ea7d6570748bf9a0e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees the Buffer.  <a href="#gaa1c00049898e0ea7d6570748bf9a0e9e"></a><br/></td></tr>
<tr class="separator:gaa1c00049898e0ea7d6570748bf9a0e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b992409df040ca36ac65c83c748e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga96b992409df040ca36ac65c83c748e71">buffer_clear</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga96b992409df040ca36ac65c83c748e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the Buffer.  <a href="#ga96b992409df040ca36ac65c83c748e71"></a><br/></td></tr>
<tr class="separator:ga96b992409df040ca36ac65c83c748e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8731a858abb423ad9cbecc8666b79dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaf8731a858abb423ad9cbecc8666b79dd">buffer_rewind</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gaf8731a858abb423ad9cbecc8666b79dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put read offset back to start.  <a href="#gaf8731a858abb423ad9cbecc8666b79dd"></a><br/></td></tr>
<tr class="separator:gaf8731a858abb423ad9cbecc8666b79dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17edc4ffe7ea459a42ffdd6540d5f213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga17edc4ffe7ea459a42ffdd6540d5f213">buffer_add</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga17edc4ffe7ea459a42ffdd6540d5f213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the buffer.  <a href="#ga17edc4ffe7ea459a42ffdd6540d5f213"></a><br/></td></tr>
<tr class="separator:ga17edc4ffe7ea459a42ffdd6540d5f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b5de7a9eb3cca96a9df0b8f90766eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gab3b5de7a9eb3cca96a9df0b8f90766eb">buffer_add_buf</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *dst, <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *src)</td></tr>
<tr class="memdesc:gab3b5de7a9eb3cca96a9df0b8f90766eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the buffer.  <a href="#gab3b5de7a9eb3cca96a9df0b8f90766eb"></a><br/></td></tr>
<tr class="separator:gab3b5de7a9eb3cca96a9df0b8f90766eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b99c0ae55b2e279339c745b6fd7bb21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga5b99c0ae55b2e279339c745b6fd7bb21">buffer_add_str</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, const char *fmt,...)</td></tr>
<tr class="memdesc:ga5b99c0ae55b2e279339c745b6fd7bb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a formated string to the buffer.  <a href="#ga5b99c0ae55b2e279339c745b6fd7bb21"></a><br/></td></tr>
<tr class="separator:ga5b99c0ae55b2e279339c745b6fd7bb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a57658aba6c18d93219334b369e8663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga3a57658aba6c18d93219334b369e8663">buffer_add_hex</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, void *data, size_t len)</td></tr>
<tr class="memdesc:ga3a57658aba6c18d93219334b369e8663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data as hex string to the buffer.  <a href="#ga3a57658aba6c18d93219334b369e8663"></a><br/></td></tr>
<tr class="separator:ga3a57658aba6c18d93219334b369e8663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914506665c6fac92ccb17f92cefd0914"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga914506665c6fac92ccb17f92cefd0914">buffer_done</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga914506665c6fac92ccb17f92cefd0914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if there are no more bytes to read.  <a href="#ga914506665c6fac92ccb17f92cefd0914"></a><br/></td></tr>
<tr class="separator:ga914506665c6fac92ccb17f92cefd0914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf2e52378c6cd765b940617cdef2bd2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaddf2e52378c6cd765b940617cdef2bd2">buffer_get_chunk</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, void *buf, size_t len)</td></tr>
<tr class="memdesc:gaddf2e52378c6cd765b940617cdef2bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some chunk of data from the Buffer.  <a href="#gaddf2e52378c6cd765b940617cdef2bd2"></a><br/></td></tr>
<tr class="separator:gaddf2e52378c6cd765b940617cdef2bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4411acab20dfabc5834fe11322bee661"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga4411acab20dfabc5834fe11322bee661">buffer_get</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga4411acab20dfabc5834fe11322bee661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the whole Buffer content.  <a href="#ga4411acab20dfabc5834fe11322bee661"></a><br/></td></tr>
<tr class="separator:ga4411acab20dfabc5834fe11322bee661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c89e4ab5d03dff079b7b861a1e04a7f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga8c89e4ab5d03dff079b7b861a1e04a7f">buffer_get_str</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga8c89e4ab5d03dff079b7b861a1e04a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the whole Buffer content as string.  <a href="#ga8c89e4ab5d03dff079b7b861a1e04a7f"></a><br/></td></tr>
<tr class="separator:ga8c89e4ab5d03dff079b7b861a1e04a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafab0893e204b624eb5181954cbc9ca"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaeafab0893e204b624eb5181954cbc9ca">buffer_get_remainder</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gaeafab0893e204b624eb5181954cbc9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the remaining data after current read offset.  <a href="#gaeafab0893e204b624eb5181954cbc9ca"></a><br/></td></tr>
<tr class="separator:gaeafab0893e204b624eb5181954cbc9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91a95b51ecfa067bdcca086f7afe4e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gab91a95b51ecfa067bdcca086f7afe4e4">buffer_extract</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, void *buf, size_t offset, size_t len)</td></tr>
<tr class="memdesc:gab91a95b51ecfa067bdcca086f7afe4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data inside the Buffer.  <a href="#gab91a95b51ecfa067bdcca086f7afe4e4"></a><br/></td></tr>
<tr class="separator:gab91a95b51ecfa067bdcca086f7afe4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0f433cbd077d3048ebdda35aa9ccb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga0e0f433cbd077d3048ebdda35aa9ccb6">buffer_dump</a> (const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga0e0f433cbd077d3048ebdda35aa9ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the Buffer contents to stderr in hex form.  <a href="#ga0e0f433cbd077d3048ebdda35aa9ccb6"></a><br/></td></tr>
<tr class="separator:ga0e0f433cbd077d3048ebdda35aa9ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b243dbcad9cb27abad40c8dcab7b22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gad4b243dbcad9cb27abad40c8dcab7b22">buffer_info</a> (const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gad4b243dbcad9cb27abad40c8dcab7b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print Buffer counters to stderr.  <a href="#gad4b243dbcad9cb27abad40c8dcab7b22"></a><br/></td></tr>
<tr class="separator:gad4b243dbcad9cb27abad40c8dcab7b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714b0a831d0f31a33e66e8ef76a26e46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga714b0a831d0f31a33e66e8ef76a26e46">buffer_size</a> (const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga714b0a831d0f31a33e66e8ef76a26e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell how much data there is in the buffer available.  <a href="#ga714b0a831d0f31a33e66e8ef76a26e46"></a><br/></td></tr>
<tr class="separator:ga714b0a831d0f31a33e66e8ef76a26e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedba431c6b8e302e0d94cd9fafc3d292"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292">buffer_left</a> (const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gaedba431c6b8e302e0d94cd9fafc3d292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell how much data is left to read in the Buffer.  <a href="#gaedba431c6b8e302e0d94cd9fafc3d292"></a><br/></td></tr>
<tr class="separator:gaedba431c6b8e302e0d94cd9fafc3d292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a7aec563f6d66a94abc1fd3e10bf1e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gae6a7aec563f6d66a94abc1fd3e10bf1e">buffer_get8</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gae6a7aec563f6d66a94abc1fd3e10bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1 byte (8 bit) number from a Buffer.  <a href="#gae6a7aec563f6d66a94abc1fd3e10bf1e"></a><br/></td></tr>
<tr class="separator:gae6a7aec563f6d66a94abc1fd3e10bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9bd1a6b474438db8cf4901ed750b92"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga5b9bd1a6b474438db8cf4901ed750b92">buffer_get16</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga5b9bd1a6b474438db8cf4901ed750b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 2 bytes (16 bit) number from a Buffer.  <a href="#ga5b9bd1a6b474438db8cf4901ed750b92"></a><br/></td></tr>
<tr class="separator:ga5b9bd1a6b474438db8cf4901ed750b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42354f61519e2c7d6ae81a695f36d580"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga42354f61519e2c7d6ae81a695f36d580">buffer_get32</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga42354f61519e2c7d6ae81a695f36d580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 4 byte (32 bit) number from a Buffer.  <a href="#ga42354f61519e2c7d6ae81a695f36d580"></a><br/></td></tr>
<tr class="separator:ga42354f61519e2c7d6ae81a695f36d580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4da4b1c370490997c9d7103cfd20a83"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gaf4da4b1c370490997c9d7103cfd20a83">buffer_get64</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gaf4da4b1c370490997c9d7103cfd20a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 8 byte (64 bit) from a Buffer.  <a href="#gaf4da4b1c370490997c9d7103cfd20a83"></a><br/></td></tr>
<tr class="separator:gaf4da4b1c370490997c9d7103cfd20a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d71a1ae861f7d9763f8f59ca317ad49"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga1d71a1ae861f7d9763f8f59ca317ad49">buffer_get16na</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga1d71a1ae861f7d9763f8f59ca317ad49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 2 bytes (16 bit) number from a Buffer, converted to host endian.  <a href="#ga1d71a1ae861f7d9763f8f59ca317ad49"></a><br/></td></tr>
<tr class="separator:ga1d71a1ae861f7d9763f8f59ca317ad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f10bed24ace6987844d4b12b39362f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga46f10bed24ace6987844d4b12b39362f">buffer_get32na</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga46f10bed24ace6987844d4b12b39362f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 4 byte (32 bit) number from a Buffer, converted to host endian.  <a href="#ga46f10bed24ace6987844d4b12b39362f"></a><br/></td></tr>
<tr class="separator:ga46f10bed24ace6987844d4b12b39362f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c32fbab871258600bbdc848358c28cb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga3c32fbab871258600bbdc848358c28cb">buffer_get64na</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga3c32fbab871258600bbdc848358c28cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 8 byte (64 bit) from a Buffer, converted to host endian.  <a href="#ga3c32fbab871258600bbdc848358c28cb"></a><br/></td></tr>
<tr class="separator:ga3c32fbab871258600bbdc848358c28cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29dc7e7f34028600a92f8b85c8f94c38"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga29dc7e7f34028600a92f8b85c8f94c38">buffer_last8</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga29dc7e7f34028600a92f8b85c8f94c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last 1 byte (8 bit) number from a Buffer.  <a href="#ga29dc7e7f34028600a92f8b85c8f94c38"></a><br/></td></tr>
<tr class="separator:ga29dc7e7f34028600a92f8b85c8f94c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32959cf4cfad7c456e46fa93175508e4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga32959cf4cfad7c456e46fa93175508e4">buffer_last16</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga32959cf4cfad7c456e46fa93175508e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last 2 byte (16 bit) number from a Buffer.  <a href="#ga32959cf4cfad7c456e46fa93175508e4"></a><br/></td></tr>
<tr class="separator:ga32959cf4cfad7c456e46fa93175508e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe524705c638959590e08ed3f63da37e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gafe524705c638959590e08ed3f63da37e">buffer_last32</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:gafe524705c638959590e08ed3f63da37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last 4 byte (32 bit) number from a Buffer.  <a href="#gafe524705c638959590e08ed3f63da37e"></a><br/></td></tr>
<tr class="separator:gafe524705c638959590e08ed3f63da37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48e50f95c09c029c265c37f2af7755f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga48e50f95c09c029c265c37f2af7755f3">buffer_last64</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b)</td></tr>
<tr class="memdesc:ga48e50f95c09c029c265c37f2af7755f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last 8 byte (64 bit) number from a Buffer.  <a href="#ga48e50f95c09c029c265c37f2af7755f3"></a><br/></td></tr>
<tr class="separator:ga48e50f95c09c029c265c37f2af7755f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2330b241d4fd267d193b05b508035935"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga2330b241d4fd267d193b05b508035935">buffer_fd_read</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, FILE *in, size_t len)</td></tr>
<tr class="memdesc:ga2330b241d4fd267d193b05b508035935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file directly into a Buffer.  <a href="#ga2330b241d4fd267d193b05b508035935"></a><br/></td></tr>
<tr class="separator:ga2330b241d4fd267d193b05b508035935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9125df8f37c49ae4443364acf711ae36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga9125df8f37c49ae4443364acf711ae36">buffer_add8</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint8_t v)</td></tr>
<tr class="memdesc:ga9125df8f37c49ae4443364acf711ae36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 1 byte (8 bit) number in binary form into the buffer.  <a href="#ga9125df8f37c49ae4443364acf711ae36"></a><br/></td></tr>
<tr class="separator:ga9125df8f37c49ae4443364acf711ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f1e47affe629232ebdabb1070f9c8c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga5f1e47affe629232ebdabb1070f9c8c6">buffer_add16</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint16_t v)</td></tr>
<tr class="memdesc:ga5f1e47affe629232ebdabb1070f9c8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 2 byte (16 bit) number in binary form into the buffer.  <a href="#ga5f1e47affe629232ebdabb1070f9c8c6"></a><br/></td></tr>
<tr class="separator:ga5f1e47affe629232ebdabb1070f9c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f36174e848271c8b0c525ea36d884fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga2f36174e848271c8b0c525ea36d884fa">buffer_add32</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint32_t v)</td></tr>
<tr class="memdesc:ga2f36174e848271c8b0c525ea36d884fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 4 byte (32 bit) number in binary form into the buffer.  <a href="#ga2f36174e848271c8b0c525ea36d884fa"></a><br/></td></tr>
<tr class="separator:ga2f36174e848271c8b0c525ea36d884fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d37d8261c678d747472e47b30c6299f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga4d37d8261c678d747472e47b30c6299f">buffer_add64</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint64_t v)</td></tr>
<tr class="memdesc:ga4d37d8261c678d747472e47b30c6299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 8 byte (64 bit) number in binary form into the buffer.  <a href="#ga4d37d8261c678d747472e47b30c6299f"></a><br/></td></tr>
<tr class="separator:ga4d37d8261c678d747472e47b30c6299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2141b987b8eb383da3f336f285384c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#gab2141b987b8eb383da3f336f285384c5">buffer_add16be</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint16_t v)</td></tr>
<tr class="memdesc:gab2141b987b8eb383da3f336f285384c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 2 byte (16 bit) number in binary form into the buffer, converted to big endian.  <a href="#gab2141b987b8eb383da3f336f285384c5"></a><br/></td></tr>
<tr class="separator:gab2141b987b8eb383da3f336f285384c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601c4d9cd62c52639f0536524830dfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga601c4d9cd62c52639f0536524830dfa5">buffer_add32be</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint32_t v)</td></tr>
<tr class="memdesc:ga601c4d9cd62c52639f0536524830dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 4 byte (32 bit) number in binary form into the buffer, converted to big endian.  <a href="#ga601c4d9cd62c52639f0536524830dfa5"></a><br/></td></tr>
<tr class="separator:ga601c4d9cd62c52639f0536524830dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbc5298e3c0a31eda31d48bfd63943a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Buffer.html#ga6bbc5298e3c0a31eda31d48bfd63943a">buffer_add64be</a> (<a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *b, uint64_t v)</td></tr>
<tr class="memdesc:ga6bbc5298e3c0a31eda31d48bfd63943a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 8 byte (64 bit) number in binary form into the buffer, converted to big endian.  <a href="#ga6bbc5298e3c0a31eda31d48bfd63943a"></a><br/></td></tr>
<tr class="separator:ga6bbc5298e3c0a31eda31d48bfd63943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flexible buffer management, idea from openssh/buffer.c. </p>
<p>This class allows us to dissect buffers into parts at will whithout the hassle of boundary checking in each and every line. Therefore it is more secure, since this system wraps all this stuff from us, so in case we're attemt to overflow a buffer or the like, the buffer functions will catch this, warn us and die. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2460ea15a51a37433b5f2e1503667e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__pcp__buffer.html">_pcp_buffer</a> <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The name used everywhere. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00062">62</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga17edc4ffe7ea459a42ffdd6540d5f213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to the buffer. </p>
<p>Adds data of the size len to the buffer and resizes the buffer, if neccessary. The write position ('end' field) will be updated accordingly.</p>
<p>Data will be copied, you can free() the given pointer after copying..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Arbitrary data to add to the Buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The size of the data to add in Bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f1e47affe629232ebdabb1070f9c8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 2 byte (16 bit) number in binary form into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint16_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2141b987b8eb383da3f336f285384c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add16be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 2 byte (16 bit) number in binary form into the buffer, converted to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint16_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f36174e848271c8b0c525ea36d884fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 4 byte (32 bit) number in binary form into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint32_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga601c4d9cd62c52639f0536524830dfa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add32be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 4 byte (32 bit) number in binary form into the buffer, converted to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint32_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d37d8261c678d747472e47b30c6299f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 8 byte (64 bit) number in binary form into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint64_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bbc5298e3c0a31eda31d48bfd63943a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add64be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 8 byte (64 bit) number in binary form into the buffer, converted to big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint64_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9125df8f37c49ae4443364acf711ae36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 1 byte (8 bit) number in binary form into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The Buffer object to write to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The uint8_t to write to the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3b5de7a9eb3cca96a9df0b8f90766eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to the buffer. </p>
<p>Adds data from the given Buffer src to the buffer and resizes the buffer, if neccessary. The write position ('end' field) will be updated accordingly.</p>
<p>Data will be copied, you can <a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free()</a> the given src Buffer after the copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The destination Buffer object to copy data into.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source Buffer object to copy data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a57658aba6c18d93219334b369e8663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data as hex string to the buffer. </p>
<p>Adds data of the size len to the buffer and resizes the buffer, if neccessary. The write position ('end' field) will be updated accordingly. Each byte will be put in its HEX form into the buffer (%02x).</p>
<p>Data will be copied, you can free() the given pointer after copying..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary data to add as hex into the Buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The size of the data to add in Bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b99c0ae55b2e279339c745b6fd7bb21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_add_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a formated string to the buffer. </p>
<p>Use printf() like syntax to add a formatted string to the buffer. Refer to the documentation of printf() for details.</p>
<p>Data will be copied, you can free() the given format string and params after copying.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="struct__pcp__buffer.html" title="A flexible buffer object wich automatically resizes, if neccessary.">Buffer</a> *x = <a class="code" href="group__Buffer.html#ga770f9c4e3caf1bcf315666a56312246f" title="Create a new string buffer.">buffer_new_str</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a class="code" href="group__Buffer.html#ga5b99c0ae55b2e279339c745b6fd7bb21" title="Add a formated string to the buffer.">buffer_add_str</a>(x, <span class="stringliteral">&quot;There are %d elements left in %s\n&quot;</span>, 4, <span class="stringliteral">&quot;list&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The printf() compatible format description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>A variable number of arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96b992409df040ca36ac65c83c748e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the Buffer. </p>
<p>This clears the buffer by filling it with zeroes and resetting all counters. Memory will not be free'd. Called from <a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free()</a> before free'ing memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga914506665c6fac92ccb17f92cefd0914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell if there are no more bytes to read. </p>
<p>This functions tells if the EOF of the buffer is reached during read operations (no more data to read left).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 of EOF has been reached or 0 if there are more data left to read. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e0f433cbd077d3048ebdda35aa9ccb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the Buffer contents to stderr in hex form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to dump. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab91a95b51ecfa067bdcca086f7afe4e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some data inside the Buffer. </p>
<p>Same as <a class="el" href="group__Buffer.html#ga4411acab20dfabc5834fe11322bee661" title="Read the whole Buffer content.">buffer_get()</a> but fetch some data chunk from somewhere in the middle of the buffer.</p>
<p>The returned pointer has to be allocated by the caller to at least a size of len bytes.</p>
<p>The read offset will be left untouched by this function.</p>
<p>Example: suppose you've got a buffer with the following content:</p>
<div class="fragment"><div class="line">AAAABBBBCCCC</div>
</div><!-- fragment --><p>Then: </p>
<div class="fragment"><div class="line">[..]</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g[4];</div>
<div class="line"><a class="code" href="group__Buffer.html#gab91a95b51ecfa067bdcca086f7afe4e4" title="Read some data inside the Buffer.">buffer_extract</a>(b, g, 4, 4);  <span class="comment">// =&gt; g now contains &#39;BBBB&#39;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The buffer to copy data to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Where to start copying.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>How mush data to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of bytes read. Returns 0 in case of an overflow, which can be catched with <a class="el" href="group__FATALS.html#ga0ea01da59af8a06c55258d78da6cb0cb" title="Prints error messages to STDERR, if there are some.">fatals_ifany()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2330b241d4fd267d193b05b508035935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_fd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a file directly into a Buffer. </p>
<p>This function reads in len bytes from the FILE stream 'in' into the Buffer. The file must already be opened by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The FILE stream to read from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes read or 0 in case of an error or EOF. Use feof() and ferror() to check this afterwards, call <a class="el" href="group__FATALS.html#ga0ea01da59af8a06c55258d78da6cb0cb" title="Prints error messages to STDERR, if there are some.">fatals_ifany()</a> in case of errors. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1c00049898e0ea7d6570748bf9a0e9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears and frees the Buffer. </p>
<p>This clears the buffer by filling it with zeroes and frees any allocated memory, including the Buffer object itself. Use this function instead of directly calling free(Buffer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4411acab20dfabc5834fe11322bee661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* buffer_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the whole Buffer content. </p>
<p>This function returns the whole buffer contents as a pointer to the internal data member (Buffer-&gt;buf). The returned pointer is allocated and filled with data up to buffer_size(Buffer), however, the allocated memory might be more than size, in fact it will be a multitude of Buffer-blocksize.</p>
<p>Don't free() the pointer directly, use <a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free()</a> always.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the buffer data storage. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b9bd1a6b474438db8cf4901ed750b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t buffer_get16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 2 bytes (16 bit) number from a Buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint16_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d71a1ae861f7d9763f8f59ca317ad49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t buffer_get16na </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 2 bytes (16 bit) number from a Buffer, converted to host endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint16_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42354f61519e2c7d6ae81a695f36d580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buffer_get32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 4 byte (32 bit) number from a Buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint32_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46f10bed24ace6987844d4b12b39362f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buffer_get32na </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 4 byte (32 bit) number from a Buffer, converted to host endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint32_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4da4b1c370490997c9d7103cfd20a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t buffer_get64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 8 byte (64 bit) from a Buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint64_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c32fbab871258600bbdc848358c28cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t buffer_get64na </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 8 byte (64 bit) from a Buffer, converted to host endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint64_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6a7aec563f6d66a94abc1fd3e10bf1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t buffer_get8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 1 byte (8 bit) number from a Buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint8_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gaddf2e52378c6cd765b940617cdef2bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_get_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some chunk of data from the Buffer. </p>
<pre class="fragment">Read some chunk of data from the Buffer, starting from current read
offset til len.

Example: suppose you've got a buffer with the following content:

@code 
AAAABBBBCCCC
@endcode

Then the following code would:

@code 
unsigned char g[4];
buffer_get_chunk(b, g, 4);  // =&gt; g now contains 'AAAA' 
buffer_get_chunk(b, g, 4);  // =&gt; g now contains 'BBBB' 
buffer_get_chunk(b, g, 4);  // =&gt; g now contains 'CCCC' 
@endcode

In order to catch buffer overflow, check the return value, which will
be 0 in case of errors. See also: fatals_ifany(), buffer_done() and buffer_left().

\param[in] b The Buffer object to read from.

\param[out] buf The destination pointer where the data will be copied to. This pointer
</pre><p> must be allocated by the caller properly and it must have at least a size of len. </p>
<pre class="fragment">\param[in] len The number of bytes to read from the Buffer.</pre> 
</div>
</div>
<a class="anchor" id="gaeafab0893e204b624eb5181954cbc9ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* buffer_get_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the remaining data after current read offset. </p>
<p>Fetch whatever is left in the buffer. This works like <a class="el" href="group__Buffer.html#ga4411acab20dfabc5834fe11322bee661" title="Read the whole Buffer content.">buffer_get()</a> but instead doesn't return everything, but only the part of the buffer, which follows after the current read offset.</p>
<p>The returned pointer will be allocated by <a class="el" href="group__Buffer.html#gaeafab0893e204b624eb5181954cbc9ca" title="Read the remaining data after current read offset.">buffer_get_remainder()</a> with a size of <a class="el" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292" title="Tell how much data is left to read in the Buffer.">buffer_left()</a>. It's up to the caller to free() the returned pointer later on.</p>
<p>Example: suppose you've got a buffer with the following content:</p>
<div class="fragment"><div class="line">AAAABBBBCCCC</div>
</div><!-- fragment --><p>Then:</p>
<div class="fragment"><div class="line">[..]</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g[4];</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *r = NULL;</div>
<div class="line"><a class="code" href="group__Buffer.html#gaddf2e52378c6cd765b940617cdef2bd2" title="Read some chunk of data from the Buffer.">buffer_get_chunk</a>(b, g, 4);    <span class="comment">// =&gt; g now contains &#39;AAAA&#39;</span></div>
<div class="line"><span class="keywordtype">size_t</span> rs = <a class="code" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292" title="Tell how much data is left to read in the Buffer.">buffer_left</a>(b);   <span class="comment">// =&gt; rs = 8</span></div>
<div class="line">r = <a class="code" href="group__Buffer.html#gaeafab0893e204b624eb5181954cbc9ca" title="Read the remaining data after current read offset.">buffer_get_remainder</a>(b);  <span class="comment">// =&gt; r now contains &#39;BBBBCCCC&#39; and has a size of 8</span></div>
<div class="line">memset(r, 0, rs);             <span class="comment">// zerofill r</span></div>
<div class="line">free(r);                      <span class="comment">// done with it</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the remaining chunk of data (copy). </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c89e4ab5d03dff079b7b861a1e04a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* buffer_get_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the whole Buffer content as string. </p>
<p>Access the Buffer content as string (char *).</p>
<p>The returned pointer is allocated and filled with data up to buffer_size(Buffer), however, the allocated memory might be more than size, in fact it will be a multitude of Buffer-blocksize.</p>
<p>The byte after buffer_size(Buffer) will be a \0.</p>
<p>Don't free() the pointer directly, use <a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free()</a> always.</p>
<p>Sample usage:</p>
<div class="fragment"><div class="line">[..]</div>
<div class="line">fprintf(stdout, <span class="stringliteral">&quot;Our buffer content: %s\n&quot;</span>, <a class="code" href="group__Buffer.html#ga8c89e4ab5d03dff079b7b861a1e04a7f" title="Read the whole Buffer content as string.">buffer_get_str</a>(b));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the buffer data storage. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4b243dbcad9cb27abad40c8dcab7b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print Buffer counters to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to print infos about. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga32959cf4cfad7c456e46fa93175508e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t buffer_last16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the last 2 byte (16 bit) number from a Buffer. </p>
<p>Doesn't increment offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint16_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe524705c638959590e08ed3f63da37e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buffer_last32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the last 4 byte (32 bit) number from a Buffer. </p>
<p>Doesn't increment offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint32_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48e50f95c09c029c265c37f2af7755f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t buffer_last64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the last 8 byte (64 bit) number from a Buffer. </p>
<p>Doesn't increment offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint64_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29dc7e7f34028600a92f8b85c8f94c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t buffer_last8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the last 1 byte (8 bit) number from a Buffer. </p>
<p>Doesn't increment offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint8_t. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedba431c6b8e302e0d94cd9fafc3d292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell how much data is left to read in the Buffer. </p>
<p>Use this function to check if it's ok to read more bytes from to buffer to avoid buffer overflows.</p>
<p>Example: suppose you've got a buffer with the following content:</p>
<div class="fragment"><div class="line">AAAABBBBCCCC</div>
</div><!-- fragment --><p>Then: </p>
<div class="fragment"><div class="line">[..]</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g[4];</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> x[16];</div>
<div class="line"><a class="code" href="group__Buffer.html#gaddf2e52378c6cd765b940617cdef2bd2" title="Read some chunk of data from the Buffer.">buffer_get_chunk</a>(b, g, 4);  <span class="comment">// =&gt; g now contains &#39;BBBB&#39;</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292" title="Tell how much data is left to read in the Buffer.">buffer_left</a>(b) &gt;= 16)    <span class="comment">// =&gt; will return 8 and therefore fail</span></div>
<div class="line">  <a class="code" href="group__Buffer.html#gaddf2e52378c6cd765b940617cdef2bd2" title="Read some chunk of data from the Buffer.">buffer_get_chunk</a>(b, x, 16);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;not enough data&quot;</span>);  <span class="comment">// =&gt; will be printed</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to get the size from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes left to read from the Buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55e468b36750f28308b7fa5dfea5b564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a>* buffer_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blocksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer. </p>
<p>Create a new buffer, initially alloc'd to blocksize and zero-filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blocksize</td><td>Initial blocksize. The smaller the more often the buffer will be resized. Choose with care.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A name for the Buffer. Just used for debugging purposes or in error messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new Buffer object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga924b013cdf1e6f7b38ba9d10b3b7112e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a>* buffer_new_buf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datasize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer from existing data. </p>
<p>Create a new buffer, but don't allocate memory nor copy data. Instead the provided data pointer will be used as internal storage directly.</p>
<p>This kind of buffer can be used to put the Buffer API into use with existing data from other sources. In most cases you'll use it for reading. However, please be aware, that it can be used for writing as well and in this case the data pointer maybe resized (by calling realloc()).</p>
<p>When calling <a class="el" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free()</a> on this Buffer, the memory pointed to by the given data pointer will not be free'd and remains accessible. It's the responsibility of the caller to do so.</p>
<p>Example using mmap(2): </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pcp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/mman.h&gt;</span></div>
<div class="line"></div>
<div class="line">FILE *RFD;</div>
<div class="line"><span class="keywordtype">size_t</span> rs;</div>
<div class="line"><a class="code" href="struct__pcp__buffer.html" title="A flexible buffer object wich automatically resizes, if neccessary.">Buffer</a> *rb;</div>
<div class="line">byte *chunk;</div>
<div class="line"><span class="keywordtype">void</span> *r;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>((RFD = fopen(<span class="stringliteral">&quot;README&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>)) == NULL) {</div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;oops, could not open README!\n&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">fseek(RFD, 0, SEEK_END);</div>
<div class="line">rs =  ftell(RFD);</div>
<div class="line">fseek(RFD, 0, SEEK_SET);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> *r = mmap(NULL, rs, PROT_READ, 0, fileno(RFD), 0);</div>
<div class="line"></div>
<div class="line">*rb = <a class="code" href="group__Buffer.html#ga924b013cdf1e6f7b38ba9d10b3b7112e" title="Create a new buffer from existing data.">buffer_new_buf</a>(<span class="stringliteral">&quot;r&quot;</span>, r, rs);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">size_t</span> blocksize = 36;</div>
<div class="line"><span class="keywordtype">void</span> *chunk = malloc(blocksize);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span>(<a class="code" href="group__Buffer.html#ga914506665c6fac92ccb17f92cefd0914" title="Tell if there are no more bytes to read.">buffer_done</a>(rb) != 1) {</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292" title="Tell how much data is left to read in the Buffer.">buffer_left</a>(rb) &lt; blocksize)</div>
<div class="line">    blocksize = <a class="code" href="group__Buffer.html#gaedba431c6b8e302e0d94cd9fafc3d292" title="Tell how much data is left to read in the Buffer.">buffer_left</a>(rb);</div>
<div class="line">  <a class="code" href="group__Buffer.html#gaddf2e52378c6cd765b940617cdef2bd2" title="Read some chunk of data from the Buffer.">buffer_get_chunk</a>(rb, chunk, blocksize);</div>
<div class="line">  <a class="code" href="group__UTILs.html#ga3dcb1fcb0f840869eab341598da50b55" title="Dump binary data as hex to stderr.">_dump</a>(<span class="stringliteral">&quot;chunk&quot;</span>, chunk, blocksize); <span class="comment">// or do something else with it</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__Buffer.html#gaa1c00049898e0ea7d6570748bf9a0e9e" title="Clears and frees the Buffer.">buffer_free</a>(rb);</div>
<div class="line"></div>
<div class="line">munmap(r, rs);</div>
<div class="line">fclose(RFD);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A name for the Buffer. Just used for debugging purposes or in error messages.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data pointer to use by the buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datasize</td><td>The size of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new Buffer object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga770f9c4e3caf1bcf315666a56312246f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a>* buffer_new_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string buffer. </p>
<p>Create a new buffer, initially alloc'd to a blocksize of 32 bytes and zero-filled. The buffer will be a string buffer. See <a class="el" href="group__Buffer.html#ga8c89e4ab5d03dff079b7b861a1e04a7f" title="Read the whole Buffer content as string.">buffer_get_str()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A name for the Buffer. Just used for debugging purposes or in error messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new Buffer object. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8731a858abb423ad9cbecc8666b79dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put read offset back to start. </p>
<p>This function sets the read offset counter back to 0 (start of the buffer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga714b0a831d0f31a33e66e8ef76a26e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Buffer.html#ga2460ea15a51a37433b5f2e1503667e8f">Buffer</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell how much data there is in the buffer available. </p>
<p>This function returns the number of bytes stored in the buffer so far. Please note, that the actual allocation might be bigger, because we always allocate memory blockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The Buffer object to get the size from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes stored in the Buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 20 2014 20:58:12 for libpcp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
