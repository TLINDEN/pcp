/*
    This file is part of Pretty Curved Privacy (pcp1).

    Copyright (C) 2013 T.Linden.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    You can contact me by mail: <tlinden AT cpan DOT org>.
*/


#include "keyprint.h"


int pcptext_infile(char *infile) {
  FILE *in;
  int insize;

  if((in = fopen(infile, "rb")) == NULL) {
    fatal("Could not open input file %s\n", infile);
    goto errtinf1;
  }
  
  fseek(in, 0, SEEK_END);
  insize = ftell(in);
  fseek(in, 0, SEEK_SET);

  if(insize == 40) {
    fprintf(stdout, "%s seems to be an empty vault file\n", infile);
    goto tdone;
  }

  /*  maybe a vault? */
  vault_t *v = pcpvault_init(infile);
  if(v != NULL) {
    fprintf(stdout, "%s is a vault file\n", infile);
    pcptext_vault(v);
    goto tdone;
  }

  /*  try z85ing it */
  char *z85 = pcp_readz85file(in);
  if(z85 == NULL) {
      fprintf(stdout, "Can't handle %s - unknown file type.\n", infile); 
      goto errtinf1;
  }

  size_t clen;
  unsigned char *bin = pcp_z85_decode((char *)z85, &clen);
  free(z85);

  if(bin == NULL) {
    fprintf(stdout, "%s isn't properly Z85 encoded - unknown file type.\n", infile);
    goto errtinf1;
  }

  /* fprintf(stdout, "have: %d, secret: %d, public: %d, sig: %d, hh: %d\n", (int)clen, */
  /* 	  (int)sizeof(pcp_key_t), (int)sizeof(pcp_pubkey_t), (int)sizeof(pcp_sig_t), (int)sizeof(UT_hash_handle)); */

  if(clen == PCP_RAW_KEYSIZE) {
    /*  secret key? */
    pcp_key_t *key = (pcp_key_t *)bin;
    key2native(key);
    if(pcp_sanitycheck_key(key) == 0) {
      fprintf(stdout, "%s is a secret key file:\n", infile);
      pcpkey_print(key, stdout);
      free(key);
      goto tdone;
    }
    else {
      fprintf(stdout, "%s looks like a secret key but failed sanity checking.\n", infile);
      free(key);
      goto errtinf1;
    }
  }

  /* FIXME: can't determine keytype by using its size */
  if(clen  == PCP_RAW_PUBKEYSIZE) {
    /*  public key? */
    pcp_pubkey_t *key = (pcp_pubkey_t *)bin;
    pubkey2native(key);
    if(pcp_sanitycheck_pub(key) == 0) {
      fprintf(stdout, "%s is a public key file:\n", infile);
      // pcppubkey_print(key, stdout, 0);
      free(key);
      goto tdone;
    }
    else {
      fprintf(stdout, "%s looks like a publickey but failed sanity checking.\n", infile);
      free(key);
      goto errtinf1;
    }
  }

  /*  still there? */
  fprintf(stdout, "%s looks Z85 encoded but otherwise unknown and is possibly encrypted.\n", infile);

 tdone:
  fatals_reset();
  return 0;

 errtinf1:
  fatals_reset();
  return 1;
}


void pcptext_key(char *keyid) {
  pcp_key_t *s = pcphash_keyexists(keyid);
  if(s != NULL) {
    if(debug)
      pcp_dumpkey(s);
    pcpkey_print(s, stdout);
  }
  else {
    pcp_pubkey_t *p = pcphash_pubkeyexists(keyid);
    if(p != NULL) {
      if(debug)
	pcp_dumppubkey(p);
      pcppubkey_print(p, stdout);
    }
    else {
      fatal("No key with id 0x%s found!\n", keyid);
    }
  }
}

void pcptext_vault(vault_t *vault) {
  printf("    Key vault: %s\n", vault->filename);
  printf("Vault version: %08X\n", vault->version);
  printf("     Checksum: ");

  int i;
  for ( i = 0;i <15 ;++i) printf("%02X:",(unsigned int) vault->checksum[i]);
  printf("%02X", vault->checksum[15]);
  printf("\n               ");
  for ( i = 16;i <31 ;++i) printf("%02X:",(unsigned int) vault->checksum[i]);
  printf("%02X", vault->checksum[31]);
  printf("\n");

  printf("  Secret keys: %d\n", HASH_COUNT(pcpkey_hash));
  printf("  Public keys: %d\n",  HASH_COUNT(pcppubkey_hash));
}

void pcpkey_printlineinfo(pcp_key_t *key) {
  struct tm *c;
  time_t t = (time_t)key->ctime;
  c = localtime(&t);
  printf("0x%s   %s   %04d-%02d-%02dT%02d:%02d:%02d  %s <%s>\n",
	 key->id,
	 (key->type ==  PCP_KEY_TYPE_MAINSECRET) ? "primary" : " secret",  
	 c->tm_year+1900, c->tm_mon+1, c->tm_mday,
	 c->tm_hour, c->tm_min, c->tm_sec,
	 key->owner, key->mail);
}

void pcppubkey_printlineinfo(pcp_pubkey_t *key) {
  struct tm *c;
  time_t t = (time_t)key->ctime;
  c = localtime(&t);
  printf("0x%s    public   %04d-%02d-%02dT%02d:%02d:%02d  %s <%s>\n",
	 key->id,
	 c->tm_year+1900, c->tm_mon+1, c->tm_mday,
	 c->tm_hour, c->tm_min, c->tm_sec,
	 key->owner, key->mail);
}

void pcppubkey_print(pcp_pubkey_t *key, FILE* out) {
  size_t zlen;
  struct tm *c;
  time_t t = (time_t)key->ctime;
  c = localtime(&t);

  fprintf(out, "  Generated by: %s Version %d.%d.%d\n",
	  PCP_ME, PCP_VERSION_MAJOR, PCP_VERSION_MINOR, PCP_VERSION_PATCH);

  fprintf(out, "        Cipher: %s\n", PCP_KEY_PRIMITIVE);

  fprintf(out, "         Owner: %s\n", key->owner);
  fprintf(out, "          Mail: %s\n", key->mail);

  fprintf(out, "        Key-ID: 0x%s\n", key->id);
  fprintf(out, "    Public-Key: %s\n", pcp_z85_encode(key->pub, 32, &zlen));

  /* 2004-06-14T23:34:30. */
  fprintf(out, " Creation Time: %04d-%02d-%02dT%02d:%02d:%02d\n",
	  c->tm_year+1900, c->tm_mon+1, c->tm_mday,
	  c->tm_hour, c->tm_min, c->tm_sec);

  unsigned char *hash = pcppubkey_getchecksum(key);
  fprintf(out, "      Checksum: ");

  int i;
  for ( i = 0;i <15 ;++i) fprintf(out, "%02X:",(unsigned int) hash[i]);
  fprintf(out, "%02X", hash[15]);
  fprintf(out, "\n                ");
  for ( i = 16;i <31 ;++i) fprintf(out, "%02X:",(unsigned int) hash[i]);
  fprintf(out, "%02X", hash[31]);
  fprintf(out, "\n");
  fprintf(out, " Serial Number: 0x%08X\n", key->serial);
  fprintf(out, "   Key Version: 0x%08X\n", key->version);
  
  char *r = pcppubkey_get_art(key);
  fprintf(out, " Random Art ID: ");
  for (i=0; i<strlen(r); ++i) {
    if(r[i] == '\n') {
      fprintf(out, "\n                ");
    }
    else {
      fprintf(out, "%c", r[i]);
    }
  }
  fprintf(out, "\n");
  
  free(hash);
  free(r);
}

void pcpkey_print(pcp_key_t *key, FILE* out) {
  size_t zlen;
  key2be(key);
  void *blob = ucmalloc(PCP_RAW_KEYSIZE);
  pcp_seckeyblob(blob, key);
  char *z85encoded = pcp_z85_encode((unsigned char*)blob, PCP_RAW_KEYSIZE, &zlen);
  key2native(key);

  free(blob);

  struct tm *c;
  time_t t = (time_t)key->ctime;
  c = localtime(&t);

  fprintf(out, "%s\n", PCP_KEY_HEADER);

  fprintf(out, "  Generated by: %s Version %d.%d.%d\n",
	  PCP_ME, PCP_VERSION_MAJOR, PCP_VERSION_MINOR, PCP_VERSION_PATCH);

  fprintf(out, "        Cipher: %s\n", PCP_KEY_PRIMITIVE);

  fprintf(out, "        Key-ID: 0x%s\n", key->id);

  /* 2004-06-14T23:34:30. */
  fprintf(out, " Creation Time: %04d-%02d-%02dT%02d:%02d:%02d\n",
	 c->tm_year+1900, c->tm_mon+1, c->tm_mday,
	 c->tm_hour, c->tm_min, c->tm_sec);

  fprintf(out, " Serial Number: 0x%08X\n", key->serial);
  fprintf(out, "   Key Version: 0x%08X\n", key->version);
  
  fprintf(out, "\n%s\n", z85encoded);

  fprintf(out, "%s\n", PCP_KEY_FOOTER);

  free(z85encoded);
}


void pcpkey_printshortinfo(pcp_key_t *key) {
  int i;
  printf("        Key-ID: 0x%s\n", key->id);
  printf("         Owner: %s\n", key->owner);
  char *r = pcpkey_get_art(key);
  printf(" Random Art ID: ");
  for (i=0; i<strlen(r); ++i) {
    if(r[i] == '\n') {
      printf("\n                ");
    }
    else {
      printf("%c", r[i]);
    }
  }
  printf("\n");
  free(r);
}

void pcppubkey_printshortinfo(pcp_pubkey_t *key) {
  int i;
  printf("        Key-ID: 0x%s\n", key->id);
  printf("         Owner: %s\n", key->owner);
  char *r = pcppubkey_get_art(key);
  printf(" Random Art ID: ");
  for (i=0; i<strlen(r); ++i) {
    if(r[i] == '\n') {
      printf("\n                ");
    }
    else {
      printf("%c", r[i]);
    }
  }
  printf("\n");
  free(r);
}

void pcpexport_yaml(char *outfile) {
  FILE *out;

  if(outfile == NULL) {
    out = stdout;
  }
  else {
    if((out = fopen(outfile, "wb+")) == NULL) {
      fatal("Could not create output file %s", outfile);
      out = NULL;
    }
  }

  if(out != NULL) {
    pcp_key_t *s;
    pcp_pubkey_t *p;

    struct tm *c;
    time_t t = time(0);
    c = localtime(&t);

    fprintf(out, "#\n# YAML export of vault %s.\n", vault->filename);
    fprintf(out, "# Generated on: %04d-%02d-%02dT%02d:%02d:%02d\n",
	    c->tm_year+1900, c->tm_mon+1, c->tm_mday,
	    c->tm_hour, c->tm_min, c->tm_sec);
    fprintf(out, "---\n");
    fprintf(out, "secret-keys:\n");

    pcphash_iterate(s) {
      fprintf(out, " -\n");
      fprintf(out, "  id:         %s\n", s->id);
      fprintf(out, "  owner:      %s\n", s->owner);
      fprintf(out, "  mail:       %s\n", s->mail);
      fprintf(out, "  ctime:      %ld\n", (long int)s->ctime);
      fprintf(out, "  version:    %08x\n", s->version);
      fprintf(out, "  serial:     %08x\n", s->serial);
      fprintf(out, "  type:       %s\n",
	      (s->type ==  PCP_KEY_TYPE_MAINSECRET) ? "primary" : " secret");
      fprintf(out, "  public:     "); pcpprint_bin(out, s->pub, 32); fprintf(out, "\n");
      if(s->secret[0] == 0) {
	fprintf(out, "  encrypted:  yes\n");
	fprintf(out, "  nonce:      "); pcpprint_bin(out, s->nonce, 24); fprintf(out, "\n");
	fprintf(out, "  secret:     "); pcpprint_bin(out, s->encrypted, 80); fprintf(out, "\n");
      }
      else {
	fprintf(out, "  encrypted:  no\n");
	fprintf(out, "  secret:     "); pcpprint_bin(out, s->secret, 32); fprintf(out, "\n");
	fprintf(out, "  edsecret:   "); pcpprint_bin(out, s->edsecret, 64); fprintf(out, "\n");
      }
      fprintf(out, "  edpub:      "); pcpprint_bin(out, s->edpub, 32); fprintf(out, "\n");
    }
    
    fprintf(out, "public-keys:\n");
    pcphash_iteratepub(p) {
      fprintf(out, " -\n");
      fprintf(out, "  id:      %s\n", p->id);
      fprintf(out, "  owner:   %s\n", p->owner);
      fprintf(out, "  mail:    %s\n", p->mail);
      fprintf(out, "  ctime:   %ld\n", (long int)p->ctime);
      fprintf(out, "  version: %08x\n", p->version);
      fprintf(out, "  serial:  %08x\n", p->serial);
      fprintf(out, "  type:    public\n");
      fprintf(out, "  public:  "); pcpprint_bin(out, p->pub, 32); fprintf(out, "\n");
      fprintf(out, "  edpub:   "); pcpprint_bin(out, p->edpub, 32); fprintf(out, "\n");
    }
  }
}

void pcpprint_bin(FILE *out, unsigned char *data, size_t len) {
  int i;
  for ( i = 0;i < len;++i)
    fprintf(out, "%02x", (unsigned int) data[i]);
}
